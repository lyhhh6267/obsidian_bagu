
### osi七层模型和tcp五层模型

自顶向下：

应用层：为应用程序提供网络服务

表示层：数据格式转换、数据压缩和数据加密

会话层：建立，断开和维护通信链接

传输层：为上层协议提供端到端的可靠传输

网络层：寻址和路由

数据链路层：定义通过通信媒介互连的设备之间传输的规范

物理层：利用物理传输介质为数据链路层提供物理链接

tcp把上三层合为一层

## TCP

### 什么是面向有连接性和面向无连接型

- 面向有连接型传输包括会话建立，传输数据和会话断开，此外还包括保证传输可靠性的各种措施，比如超时重传，流量控制等，常见的面向有连接传输有tcp
- 面向无连接型传输仅提供基本的传输数据的功能，即使接收端不存在，发送端也能发送数据包，常见的面向无连接传输有udp，ip

### 什么是udp和tcp？区别是什么

udp和tcp都是传输层协议，用来建立可靠的通信传输链接的

udp仅提供最基本的数据传输功能，至于传输时链接的建立和断开，传输可靠性的保证这些udp统统不关心，而是把这些问题抛给udp上层的应用层去处理，自己仅提供传输层协议的基本功能

tcp作为一种面向有链接的协议，只有在确认通信对端存在是才会发送数据，会在传输开始前建立连接，传输结束后断开连接，此外，tcp还采取了多种措施保障传输的可靠性

区别：
- tcp是面向有连接型，udp是面向无连接型
- tcp是一对一传输，udp支持一对一、一对多、多对一和多对多的交互通信；
- tcp是面向字节流的，即把应用层传来的报文看成字节流，将字节流拆分成大小不等的数据块，并添加tcp首部；udp是面向报文的，对应用层传下来的报文不拆分也不合并，仅添加udp首部
- tcp支持传输可靠性的多种措施，包括保证包的传输顺序，重发机制，流量控制和拥塞控制；udp仅提供最基本的数据传输能力

### tcp对应的应用层协议有哪些？udp？

tcp：
- ftp：文件传输协议
- ssh：远程登录协议
- http：web服务器传输超文本到本地浏览器的超文本传输协议


udp：
- dns：域名解析协议
- tftp：简单文件传输协议
- snmp：简单网络管理协议


### 介绍一下tcp三次握手，为什么不是两次不是四次&&&




### 介绍一下TCP四次挥手？为什么不是三次？为什么不是五次？&&&


### 在四次挥手中，为什么客户端进入TIME_WAIT状态等待2* MSL时间，而不是直接进入CLOSED状态？

-   客户端发送给服务端回执后，有可能这个回执报文在传输途中丢失等原因，服务端并没有收到，此时服务端会再次向客户端发送FIN=1的断开请求报文，如果客户端没有等待2*MSL时间而直接进入了CLOSED状态，客户端就会收不到服务端再次发送的断开连接的请求报文，导致服务端无法进入CLOSED状态；
-   等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

### ARQ协议

arq协议--自动重传协议（Automatic Repeat-reQuest），意识是如果发送方在发送后一段时间之内没有收到确认回执，它通常会重新发送。arq协议包括停止等待arq协议和连续arq协议

停止等待arq协议：停止等待ARQ协议是指，在停止等待中如果接收端没有收到发送端发来的分组，接收端就不会给发送端发送确认回执，此时发送端会重新发送之前的报文分组。发送端会维护一个超时计时器，超时时间会设置的比数据在传输往返过程的时间要长一些。

连续arq协议：连续ARQ协议是指，发送端维护一个“窗口”，“窗口”内可以有多个分组，窗口的大小就是窗口中分组的个数，凡是位于“窗口”内的分组可以连续发送出去而不必等待接收端返回的确认回执，对按序到达的最后一个分组，接收端会向发送端发送确认回执，如果有分组没有正确到达，会返回最后一个正确达到的分组序号，该序号后面的分组会重新发送给接收端。

举个例子，窗口大小为4，发送时第1、2、4号分组均成功发送，3号分组发送失败，接收端会给发送端发送2号分组的确认回执，然后发送端会把2号分组之后的数据（3号分组和4号分组）重新再发送一遍，即使4号分组是发送成功的。

在连续ARQ协议中，发送端会维护一块发送端的数据缓存，“窗口”里的分组都会在这个缓存中，当需要重新发送“窗口”中的分组报文时，便会从缓存里读取分组并发送。

连续 ARQ 协议可提高信道利用率。

### tcp的流量控制

流量控制是为了控制发送端发送数据的速率，保证接收端能将本应接受的所有报文分组接受成功，否则会触发自动重传机制造成网络流量的浪费

tcp流量控制的具体操作是：接收端会通知发送端自己能接受的数据大小，于是发送端会发送不超过这个数据量的数据，这个大小被称为“窗口”的大小，在tcp首部中专门有一个字段表示“窗口”的大小，这个值越大代表网络的吞吐量越高


### tcp的拥塞控制

计算机网络都处在一个共享的环境中，在通信开始时如果立即把大量的数据注入到网络，可能会引起网络阻塞，甚至带来网络瘫痪。tcp为了防止该问题的出现，采用了拥塞控制的策略，常见的拥塞控制策略有慢启动，拥塞避免，快重传和快恢复

### 什么是tcp粘包

如果客户端连续不断向服务端发送数据包时，服务带你接受的数据会出现两个数据包粘在一起的情况

1. tcp是基于字节流的，虽然应用层和tcp传输层之间的数据交互是大小不等的数据块，但是tcp把这些数据块仅仅看成一连串的无结构的字节流，没有边界
2. 从tcp的帧结构也可以看出，在tcp的首部没有表示数据长度的字段

基于上面两点，在使用tcp传输数据时，才有粘包或者拆包的现象发生的可能，一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包

### 粘包是如何产生的

（1）发送方产生粘包

采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。

一句话：要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。

（2）接收方产生粘包

接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度）。

一句话：接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。


如何避免粘包？

有以下两个措施：

-   在每个包的末尾加上特殊字符，用以区分连续的两个包；
-   在报文首部添加包的长度。

## HTTP


### 什么是HTTP协议？HTTP和HTTPS的区别？


http协议是应用层的协议，中文名称是超文本传输协议，是客户端和服务端相互通信时将信息以http报文的形式传输。

1.  HTTP是基于**浏览器/服务器**架构；
2.  HTTP是**无状态**协议：HTTP本身并不保存用户的任何信息，也不会对传输的数据，状态信息进行持久化；
3.  HTTP是**无连接**协议：每次连接只处理一个请求，服务器处理完用户请求，即断开连接，借此节约传输时间。

https可以简单的理解为：https = http + 加密 + 认证 + 完整性保护。

http的缺点：
1. 通信使用明文，内容可能被窃听
2. 通信双非的身份无法得到验证，身份可能遭遇伪装
3. 无法验证报文的完整性

https的改进措施：
1. 加密：https协议通过SSL或者TLS协议将报文内容进行加密，client端进行加密，服务端进行解密
2. 验证：通过值得信赖的第三方机构颁布证书，即可确认通信双方的身份。客户端持有证书即可完成客户端身份的确认，客户端通信前会查看服务端的证书
3. 完整性保护：可以通过md5等散列码进行通信内容的校验


### 为什么说http协议是无状态协议？怎么解决Http协议无状态协议?

http协议是一种无状态协议，协议自身不对请求和响应之间的通信状态进行保存，即对发送过来的请求和响应都不做持久化处理，把http协议设计的如此简单是为了更快地处理大量事务。

为了解决http协议不能保存通信状态的问题，引入了cookie状态管理。Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。Cookie会根据从服务端发送的响应报文的一个叫Set-Cookie的首部字段，通知客户端保存Cookie。当下次客户端再往该服务端发送请求时，客户端会自动在请求报文中加入Cookie值发送出去，服务端发现客户端发来的Cookie后，会检查是哪一个客户端发来的连接请求，对比服务器上的记录，最后得到之前的状态信息。

### URI和URL的区别?

URI: Uniform Resource Identifier，统一资源标识符，用来唯一标识互联网中的一份资源。

URL: Uniform Resource Locator，统一资源定位符，我们访问网站的网址就是URL。

URL是URI的子集。

URI的目的就是唯一标识互联网中的一份资源，具体可以用资源名称、资源地址等，但是资源地址是目前使用最广泛的，因此URL就容易和URI混淆。URI相当于抽象类，URL就是这个抽象类的具体实现类。

### put和post的却别

put是幂等的，post不是。

幂等是数学的一个用语，对于单个输入或者无输入的运算方法，如果每次都是同样的结果，则称其是幂等的。也就是说，如果一个网络重复执行多次，产生的效果是一样的，那就是幂等（idempotent）。

post在发请求的时候，服务器会每次都创建一个文件，而put发请求的时候，是更新文件而不是创建文件，因此put是幂等的。

### http请求报文和响应报文的组成？&&&

### 常见的http返回码有哪些？

-   200：请求被正常处理
-   204：请求被受理但没有资源可以返回
-   206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
-   301：永久性重定向
-   302：临时重定向
-   303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
-   304：发送附带条件的请求时，条件不满足时返回，与重定向无关
-   307：临时重定向，与302类似，只是强制要求使用POST方法
-   400：请求报文语法有误，服务器无法识别
-   401：请求需要认证
-   403：请求的对应资源禁止被访问
-   404：服务器无法找到对应资源
-   500：服务器内部错误
-   503：服务器正忙

### HTTP 通信过程

1.  用户输入网址
2.  DNS服务器进行域名解析
3.  进行TCP三次握手
4.  建立TCP连接
5.  发送HTTP请求
6.  服务器接受请求并返回HTTP响应
7.  释放连接TCP连接：若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
8.  客户端浏览器解析HTML内容：客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。