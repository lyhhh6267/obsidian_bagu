
### GMP

#### go的调度

go 的调度是基于GMP模型，G= goroutine协程任务信息单元 无数量限制；M=machine，M - worker thread, or machine，代表一个线程，实际执行体，最大值1w，所有G任务是在M上执行；P=processor，代表一个处理器，每一个被允许的M都会绑定一个G，默认和逻辑cpu数量

调度抽象：某个os线程m不断尝试拿资源P并找任务G执行
调用过程： 创建一个G对象，如果有空闲的P，创建一个M
M会启动一个底层线程，循环执行能找到G
G任务按照队列顺序执行，先从本地队列找，没有则从全局队列找

schedt是全局资源池和任务池
有一个专门的sysmon系统监控器来监控和管理，记录所有P的G任务计数schedtick，如果某个P的schedtick一直没有递增，说明这个P一直在执行一个G任务，如果超过一定时间就会为G增加标记，并且该G执行非内联函数时中断自己并把自己加到队尾。

#### 是什么是GMP

G 代表着 goroutine，P 代表着上下文处理器，M 代表 thread 线程，在GMP模型中，有一个全局队列：存放等待运行的G，还有一个P的本地队列：也是存放等待运行的G，数量有限，不超过256个。GMP调度从go func()开始创建一个goroutine，艰辛的G有限保存在P的本地队列中，满了则保存到全局队列中。M会从P的队列中取一个可执行状态的G来执行，如果P的本地队列为空，则会从其他MP组合中偷取一个可执行的G来执行，当M执行某一个G时发了系统调用或者阻塞，M阻塞，如果这个时候G在执行，runtime会把这个M从P中摘除，然后穿件一个新的M来服务这个P，当M系统调用结束，这个G会尝试获取一个空间的P来执行，并放入到这个P的本地丢了，如果这个M变成休眠状态，加入到空闲线程中，然后整个G就会被放入到全局队列中

G 的个数理论上是无限制的，但是受内存限制，P 的数量一般建议是逻辑 CPU 数量的 2 倍，M 的数据默认启动的时候是 10000，内核很难支持这么多线程数，所以整个限制客户忽略，M 一般不做设置，设置好 P，M 一般都是要大于 P。

#### 进程、线程、协程有什么区别&&&os

进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程建的通信方式在通信

线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。

协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行

#### 抢占式调度是如何抢占的

**基于协作式抢占**

**基于信号量抢占**

#### M和P的数量问题&&&&

### 锁

#### 除了mutex以外还有那些方式安全读写共享变量？

* 将共享变量的读写放到一个 goroutine 中，其它 goroutine 通过 channel 进行读写操作。

* 可以用个数为 1 的信号量（semaphore）实现互斥

* 通过 Mutex 锁实现

#### go如何实现原子操作

原子操作就是不可中断的操作，外界是看不到原子操作的中间状态，要么看到原子操作已经完成，要么看到原子操作已经结束。在某个值的原子操作执行的过程中，CPU 绝对不会再去执行其他针对该值的操作，那么其他操作也是原子操作。

Go 语言的标准库代码包 sync/atomic 提供了原子的读取（Load 为前缀的函数）或写入（Store 为前缀的函数）某个值（这里细节还要多去查查资料）。

**原子操作与互斥锁的区别**

1）、互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。

2）、原子操作是针对某个值的单个互斥操作。

#### mutex是悲观锁还是乐观锁

是悲观锁

悲观锁：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。

**乐观锁**

乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量

#### mutex有几种模式？

1. 正常模式
	1. 当前的mutex只有一个goroutine来获取，name没有竞争，直接返回
	2. 新的goroutine进来，如果当前mutex已经被获取，则该G进入一个先入先出的waiter的队列，在mutex被释放后，waiter按照先进先出的方式获取锁，该G会处于自旋状态（不挂起，继续占有cpu）
	3. 新的G进来，mutex处于空闲状态，将参与竞争，新来的G有先天优势，它们正在cpu中运行，可能数量还不少，所以在高并发情况下，被唤醒的waiter可能获取不到锁，这是，他会被插入到队列的前面。如果waiter获取不到锁的时间超过阈值1ms，那么mutex就进入到饥饿模式
2. 饥饿模式
	在饥饿模式中，mutex的拥有者会把锁直接交给队列最前面的waiter。进来的G不会尝试获取锁，即使看起来锁没有被持有，它不会去抢也不会自旋，而是加入到waiter队列的尾部。当拥有mutex的waiter发现下面两种情况之一时会把mutex转换成正常模式
	1. 此waiter已经是队列中的最后一个waiter了，没有其他等待锁的G
	2. 该waiter的等待时间小于1ms

#### goroutine 的自旋占用资源如何解决

自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。

**自旋的条件如下：**

1）还没自旋超过 4 次,

2）多核处理器，

3）GOMAXPROCS > 1，

4）p 上本地 goroutine 队列为空。

mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。

### 并发

#### go中常用的三种并发模型

1. 通过`channel`通知实现并发控制：
	无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。从无缓冲的通道定义来看，发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同步通道。当主 `goroutine` 运行到 `<-ch` 接受 `channel` 的值的时候，如果该 `channel` 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制
2. 通过`sync`包中的`WaitGroup`实现并发控制
3. 使用context包上下文吧实现并发控制


#### 怎么控制并发数

一、有缓冲通道

通过通道中没有数据时读取堵塞，通道已满是写入堵塞的特性，控制并发数量

 二、第三方库实现的协程池

#### 多个G对同一个map协会panic，异常是否可以用defer捕获

可以捕获异常，但是只能捕获一次，go可以用多值返回来返回错误。不用用异常代替错误，更不要用来控制流程，对异常处理的原则是：多用error少用panic


### GC &&&

#### go中gc是怎么实现的

细分常见问题：1、GC机制随着golang版本变化如何变化的？2、三色标记法的流程？3、插入屏障、删除屏障，混合写屏障（具体的实现比较难描述，但你要知道屏障的作用：避免程序运行过程中，变量被误回收；减少STW的时间）4、虾皮还问了个开放性的题目：你觉得以后GC机制会怎么优化？

Go 的 GC 回收有三次演进过程，Go V1.3 之前普通标记清除（mark and sweep）方法，整体过程需要启动 STW，效率极低。GoV1.5 三色标记法，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要 STW)，效率普通。GoV1.8 三色标记法，混合写屏障机制：栈空间不启动（全部标记成黑色），堆空间启用写屏障，整个过程不要 STW，效率高。

Go1.3 之前的版本所谓标记清除是先启动 STW 暂停，然后执行标记，再执行数据回收，最后停止 STW。Go1.3 版本标记清除做了点优化，流程是：先启动 STW 暂停，然后执行标记，停止 STW，最后再执行数据回收。

Go1.5 三色标记主要是插入屏障和删除屏障，写入屏障的流程：程序开始，全部标记为白色，1）所有的对象放到白色集合，2）遍历一次根节点，得到灰色节点，3）遍历灰色节点，将可达的对象，从白色标记灰色，遍历之后的灰色标记成黑色，4）由于并发特性，此刻外界向在堆中的对象发生添加对象，以及在栈中的对象添加对象，在堆中的对象会触发插入屏障机制，栈中的对象不触发，5）由于堆中对象插入屏障，则会把堆中黑色对象添加的白色对象改成灰色，栈中的黑色对象添加的白色对象依然是白色，6）循环第 5 步，直到没有灰色节点，7）在准备回收白色前，重新遍历扫描一次栈空间，加上 STW 暂停保护栈，防止外界干扰（有新的白色会被添加成黑色）在 STW 中，将栈中的对象一次三色标记，直到没有灰色，8）停止 STW，清除白色。至于删除写屏障，则是遍历灰色节点的时候出现可达的节点被删除，这个时候触发删除写屏障，这个可达的被删除的节点也是灰色，等循环三色标记之后，直到没有灰色节点，然后清理白色，删除写屏障会造成一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉。

GoV1.8 混合写屏障规则是：

1）GC 开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需 STW)，2）GC 期间，任何在栈上创建的新对象，均为黑色。3）被删除的对象标记为灰色。4）被添加的对象标记为灰色。


#### go 是 gc 算法是怎么实现的？&&&

#### GC 中 stw 时机，各个阶段是如何解决的？

**底层原理，自行百度一下，我等渣渣简历都过不了BAT，字节，虾皮，特使拉以及一些国Q还能收到面试邀约**。

1）在开始新的一轮 GC 周期前，需要调用 gcWaitOnMark 方法上一轮 GC 的标记结束（含扫描终止、标记、或标记终止等）。

2）开始新的一轮 GC 周期，调用 gcStart 方法触发 GC 行为，开始扫描标记阶段。

3）需要调用 gcWaitOnMark 方法等待，直到当前 GC 周期的扫描、标记、标记终止完成。

4）需要调用 sweepone 方法，扫描未扫除的堆跨度，并持续扫除，保证清理完成。在等待扫除完毕前的阻塞时间，会调用 Gosched 让出。

5）在本轮 GC 已经基本完成后，会调用 mProf_PostSweep 方法。以此记录最后一次标记终止时的堆配置文件快照。

6）结束，释放 M。

#### GC的触发时机

初级必问，分为系统触发和主动触发。

1）gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。

2）gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。时间周期以runtime.forcegcperiod 变量为准，默认 2 分钟。

3）gcTriggerCycle：如果没有开启 GC，则启动 GC。

4）手动触发的 runtime.GC 方法。

### 内存相关

### 内存泄漏，什么情况下会泄露，怎么定位排查

go中内存泄露一半时G泄露，就是G没有被关闭，或者是没有添加超时控制，让G一直处于堵塞状态，不能被GC

**内存泄露有下面一些情况**

1）如果 goroutine 在执行时被阻塞而无法退出，就会导致 goroutine 的内存泄漏，一个 goroutine 的最低栈大小为 2KB，在高并发的场景下，对内存的消耗也是非常恐怖的。

2）互斥锁未释放或者造成死锁会造成内存泄漏

3）time.Ticker 是每隔指定的时间就会向通道内写数据。作为循环触发器，必须调用 stop 方法才会停止，从而被 GC 掉，否则会一直占用内存空间。

4）字符串的截取引发临时性的内存泄漏

````go
func main() {
	var str0 = "12345678901234567890"
	str1 := str0[:10]
}
````

5）切片截取引起子切片内存泄漏

```go
func main() {
	var s0 = []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s1 := s0[:3]
}
```

6）函数数组传参引发内存泄漏【如果我们在函数传参的时候用到了数组传参，且这个数组够大（我们假设数组大小为 100 万，64 位机上消耗的内存约为 800w 字节，即 8MB 内存），或者该函数短时间内被调用 N 次，那么可想而知，会消耗大量内存，对性能产生极大的影响，如果短时间内分配大量内存，而又来不及 GC，那么就会产生临时性的内存泄漏，对于高并发场景相当可怕。】

排查方式：

一般通过 pprof 是 Go 的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是 CPU 使用情况、内存使用情况、goroutine 运行情况等，当需要性能调优或者定位 Bug 时候，这些记录的信息是相当重要。

#### 内存逃逸&&&

1. 本该分配到栈上的变量，跑到了堆上，导致了内存逃逸
2. 栈是高地址到低地址，栈上的变量，函数介绍后变量会跟着回收掉，不会有额外性能的开销
3. 变量从栈逃逸到堆上，如果要回收掉，就要进行GC，那么gc一点会带来额外的性能开销。编程语言不断优化gc算法，主要目的都是为了减少gc带来的额外性能开销，变量一旦逃逸就会导致性能开销变大

内存逃逸的情况如下：

1. 方法内返回局部变量指针
2. 向channel发送指针数据
3. 在闭包中引用包外的值
4. 在slice或map中储存指针
5. 切片扩容后长度太大
6. 在接口类型上调用方法

#### go是怎么分配内存的&&&

#### channel分配在栈上还是堆上，那些对象分配在哪？&&&

Channel 被设计用来实现协程间通信的组件，其作用域和生命周期不可能仅限于某个函数内部，所以 golang 直接将其分配在堆上

准确地说，你并不需要知道。Golang 中的变量只要被引用就一直会存活，存储在堆上还是栈上由内部实现决定而和具体的语法没有关系。

知道变量的存储位置确实和效率编程有关系。如果可能，Golang 编译器会将函数的局部变量分配到函数栈帧（stack frame）上。然而，如果编译器不能确保变量在函数 return 之后不再被引用，编译器就会将变量分配到堆上。而且，如果一个局部变量非常大，那么它也应该被分配到堆上而不是栈上。

当前情况下，如果一个变量被取地址，那么它就有可能被分配到堆上,然而，还要对这些变量做逃逸分析，如果函数 return 之后，变量不再被引用，则将其分配到栈上。

#### 大对象和小对象，为什么小对象多了会造成gc压力

小于等于 32k 的对象就是小对象，其它都是大对象。一般小对象通过 mspan 分配内存；大对象则直接由 mheap 分配内存。通常小对象过多会导致 GC 三色法消耗过多的 CPU。优化思路是，减少对象分配。

小对象：如果申请小对象时，发现当前内存空间不存在空闲跨度时，将会需要调用 nextFree 方法获取新的可用的对象，可能会触发 GC 行为。

大对象：如果申请大于 32k 以上的大对象时，可能会触发 GC 行为。


### go struct能不能比较

因为map和slice不能用== 比较，如果结构体中包含上面两种类型，则不能计较，这两种类型也不能作为map的key

map的key类型 map中的key可以是任何的类型，只要它的值能比较是否相等，Go的 语言规范 已精确定义，Key的类型可以是： 布尔值 数字 字符串 指针 通道 接口类型 结构体 只包含上述类型的数组。 但不能是： slice map function 
Key类型只要能支持 == 和 != 操作符，即可以做为Key，当两个值 == 时，则认为是同一个Key。


###  go defer

先return再defer，return不是原子操作，先将返回值存在栈中再执行跳转，defer的执行时机是跳转前

defer的作用：defer延迟函数，释放资源，收尾工作；如释放锁，关闭文件，关闭连接，捕获panic

避坑：defer紧跟在资源打开后面，否则defer可能得不到执行导致内存泄露



多个defer的顺序，defer在上面时机会修改返回值：调用顺序是LIFO后进先出，可以理解为压入栈中
	每个defer语句都对应一个_defer实例，多个实例使用指针连接起来形成单链表，保存在goroutine数据结构中，每次插入_defer实例，军插入到链表的头部，杉树结束后再一次从头部取出，从而形成先进后出的效果

### select 

1. goroutine超时设置，防止goroutine一直执行导致内存不释放等问题
2. 判断channel是否空或满，如实现一个池线程，当channel已被写满，暂无空闲worker在进行读取，进入default，返回一个暂无可分配资源错误。
3. go的select为go提供了多路io复用机制，和其他io复用一样，用于检测是否读写时间是否ready：每个线程或者进程都先到注册和接受的channel注册，然后堵塞，然后只有一个线程在运输，当注册的线程和进程准备好数据后，channel会根据注册的信息得到相应的数据

select是单协程操作

select的case表达式必须是channel类型，所有的case会被求值，求值顺序自上而下，从左至右。如果有多个case可以完成，则会随机执行 其中一个，如果有default分支则执行default。如果没有default，也没有可执行操作知识，select则会一直堵塞，直到至少一个io操作可以进行

break可以跳出select

### context包

context在多个goroutine中是并发安全的，context是上下文的意思，在线程和协程中都有这个概念，只程序单元中的一个运行状态，现场，快照，包含。

Go 的 Context 的数据结构包含 Deadline，Done，Err，Value，Deadline 方法返回一个 time.Time，表示当前 Context 应该结束的时间，ok 则表示有结束时间，Done 方法当 Context 被取消或者超时时候返回的一个 close 的 channel，告诉给 context 相关的函数要停止当前工作然后返回了，Err 表示 context 被取消的原因，Value 方法表示 context 实现共享数据存储的地方，是协程安全的。context 在业务中是经常被使用的，

**其主要的应用 ：**

1：上下文控制，2：多个 goroutine 之间的数据交互等，3：超时控制：到某个时间点超时，过多久超时。

### slice

#### len，cap，共享和扩容

len：切片的长度，访问时间复杂度o1，go的slice底层是对数组的引用

cap：切片的容量，扩容默认两倍，到1k长度后扩展采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍。

-   首先判断，如果新申请容量大于 2 倍的旧容量，最终容量就是新申请的容量 
-   否则判断，如果旧切片的长度小于 1024，则最终容量就是旧容量的两倍 
-   否则判断，如果旧切片长度大于等于 1024，则最终容量从旧容量开始循环增加原来的1/4, 直到最终容量大于等于新申请的容量

扩容： 每次扩容底层先分配新的容量的内存空间，再讲老数组拷贝到新内存空间，因为这个操作不是并发安全的。所以并发进行append，读到内存中的老数组可能为同一个导致append的数据丢失

共享：selice底层是对数组的引用，当两个切片引用同一个数组片段就会共享底层数组，当slice发生内存的重新分配时，会对共享进行隔断

数组计算长度需要遍历整个数组，时间复杂度为O(n)；切片本身具有len字段，时间复杂度为O(1)

#### slice的底层原理

slice是无固定长度的数组，大小为24个字节，底层是一个结构体

```go
type slice struct {
	array unsafe.Pointer // 数组指针，8个字节
	len   int // 切片的长度，8个字节
	cap   int // 切片的容量，8个字节
}
```

slice有三种状态：nil、空和零。

#### slice深拷贝和浅拷贝的区别

-   深拷贝：深拷贝拷贝的是数据本身，在内存中新开辟一个内存地址存放数据，修改新对象不会影响原来的对象。
-   浅拷贝：指的是拷贝数据的地址，本质上是指向同一个内存空间，修改内容会影响到原来的对象。

深拷贝方式：copy函数、通过遍历老切片append到新切片中。

```go
package main
 
import (
	"fmt"
)
 
func main() {
	// 使用copy函数拷贝
	oldSli := []int{1, 2, 3}
	newSli := make([]int, 3)
	res := copy(newSli, oldSli) // 返回拷贝元素的数量
	fmt.Println(oldSli, newSli, res)
 
	newSli1 := []int{}
	res1 := copy(newSli1, oldSli) // 这里拷贝未成功，原因是新切片的容量为0
	fmt.Println(oldSli, newSli1, res1)
 
	// 使用遍历老切片，append函数拷贝
	for _, val := range oldSli {
		newSli1 = append(newSli1, val) // append函数内部会自动对slice扩容
	}
	fmt.Println(oldSli, newSli1)
}
 
// 输出
[1 2 3] [1 2 3] 3
[1 2 3] [] 0
[1 2 3] [1 2 3]
```


浅拷贝方式：引用类型的变量默认的赋值操作就是浅拷贝

```go
package main
 
import (
	"fmt"
)
 
func main() {
	oldSli := []int{1, 2, 3}
	newSli := oldSli
	fmt.Println(oldSli, newSli)
	newSli[0] = 4
	fmt.Println(oldSli, newSli)
}
 
// 输出
[1 2 3] [1 2 3]
[4 2 3] [4 2 3]
```

#### slice的内存泄露



### map

go map底层是一个hash表，通过键值进行映射，go底层的map存储着hash值进行索引，最终是在底层使用数组存储key和value


map的底层是hash table(hmap类型)，对key值进行了hash，并将结果的低八位用于确定key/value存在于哪个bucket（bmap类型）。再将高八位与bucket的tophash进行依次比较，确定是否存在。出现hash冲撞时，会通过bucket的overflow指向另一个bucket，形成一个单向链表。每个bucket存储8个键值对。

**golang使用的hash算法根据硬件选择，如果cpu支持aes，那么使用aes hash，否则使用memhash**

go会生成16位hash值，，前半部分就叫做**高位哈希值**，后半部分就叫做**低位哈希值**。
**高位哈希值hmap：是用来确定当前的bucket（桶）有没有所存储的数据的。
理解为，hmap指向了一个空bucket数组**

**低位哈希值bmap：是用来确定，当前的数据存在了哪个bucket（桶）
每个桶最多放8个key和value**

![[Pasted image 20230302152416.png]]

#### map并发安全问题

map类型是容易发生并发访问问题的。不注意就容易发生程序运行时并发读写导致的panic。 Go语言内建的map对象不是线程安全的，并发读写的时候运行时会有检查，遇到并发问题就会导致panic。并发安全可以使用sync.map或者使用读写锁实现并发安全map

#### 用map实现顺序读取

==如果要实现map的顺序读取，需要使用一个slice来存储map的key并按照顺序进行排序。==

#### map循环是有序还是无序？&&&

无序的，map因为扩张而重新hash是，各键值项存储位置都可能发生改变，顺序自然无法保证，所以官方避免大家依赖顺序，直接打乱处理。for range map在开始处理循环逻辑的时候就做了随机播种

#### map中删除一个key，它的内存会释放么？&&&

如果删除的元素是值类型，内存不会自动释放

如果删除的元素是引用类型，内存会自动释放，但释放的内存是子元素应用类型的内存占用

将map设置为nil后，内存会回收

#### nil map和空map有什么不同

nil map是未初始化，空map是长度为空

可以对未初始化的map进行取值，取出来的是空，不能对未初始化的map进行赋值，会抛出异常

通过fmt打印map是，空map和nil map结构是一样的都是map[] 所以要通过map == nil来判断



#### 用go实现set

用map实现，如果要并发安全就要sync.map，要注意下set中的delete函数需要使用 `delete(map)`来实现，但是这个并不会释放内存，除非value也是一个子map。当进行多次delete后，可以使用make来重建map。

#### 用go实现消息队列（多生产者、多消费者）

用sync.map来管理topic，用channel来做队列

### channel

#### channel是否线程安全？锁用在上面地方？&&&

是线程安全，channel读写都是原子操作。而且`Go`的设计思想就是:不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是`Channel`。也就是说，设计`Channel`的主要目的就是在多任务间传递数据的，这当然是安全的。

#### channel的底层实现原理&&&

channel本质上是一个8个字节的指针，指向hchan结构体

```go
// A header for a Go channel.
type hchan struct {
	qcount   uint           // 循环数组里的元素个数
	dataqsiz uint           // 循环数组的长度，如ch := make(chan int, 10)。此处的10即dataqsiz
	elemsize uint16         // 要发送或接收的数据类型大小
	buf      unsafe.Pointer // 当channel设置了缓冲数量时，该buf指向一个存储缓冲数据的区域，该区域是一个循环队列的数据结构
	closed   uint32         // 关闭状态
	sendx    uint           // 当channel设置了缓冲数量时，数据区域即循环队列此时已发送数据的索引位置
	recvx    uint           // 当channel设置了缓冲数量时，数据区域即循环队列此时已接收数据的索引位置
	recvq    waitq          // 想读取数据但又被阻塞住的goroutine队列
	sendq    waitq          // 想发送数据但又被阻塞住的goroutine队列
	lock     mutex
	...
}
```

其中waitq是一个结构体

```go
type waitq struct {
	first *sudog
	last  *sudog
}
```

一、无缓冲channel读写

根据读写顺序可以分为先读后写和先写后读。

先读后写：由于channel是无缓冲的，G1（读goroutine）会被挂在recvq队列，然后休眠。当G2（写goroutine）写入数据时，发现recvq队列中的G1，就会将数据传给G1，并设置G1 goready函数，等待下次调度运行，同时会将G1从等待队列中移出。

![[Pasted image 20230303011713.png]]

![[Pasted image 20230303011721.png]]

先写后读：由于channel是无缓冲的，因此G1（写goroutine）会被挂在sendq队列，然后休眠。当G2（读goroutine）来读数据时，发现sendq队列中的G1，将G1的数据取出来，并对G1设置goready函数，这样下次再发生调度时，G1就可以正常运行，并且会从等待队列中移除。

![[Pasted image 20230303011741.png]]

![[Pasted image 20230303011748.png]]

二、有缓冲channel

先读再写：先判断缓冲区是否有数据，如果有数据则从缓冲区取数据，取完数据之后如果sendq队列中有数据则会按序将sendq队列中的数据放入缓冲区尾部。如果没有数据则将G1（读goroutine）保存在recevq队列，并且休眠。当G2（写goroutine）写数据时，会判断缓冲区是否已满，如果已满则将G2挂在sendq队列，并休眠。如果未满则将G2（写goroutine）保存在缓冲区。

先写再读：先判断缓冲区是否已满，如果未满则将G1（写goroutine）保存在缓冲区，如果已满则将G1挂在sendq队列，并且休眠。当G2（读goroutine）读数据时，优先去缓冲区取数据，如果缓冲区没有数据则挂在recevq队列，并且休眠。当G2取完数据之后如果sendq队列中有数据则会按序将sendq队列中的数据放入缓冲区尾部。

![[Pasted image 20230303012349.png]]

![[Pasted image 20230303012356.png]]

ring buffer实现？  
channel中使用了 ring buffer（环形缓冲区) 来缓存写入的数据。ring buffer 有很多好处，而且非常适合用来实现 FIFO 式的固定长度队列。

![[Pasted image 20230303012410.png]]

上图展示的是一个缓冲区为 8 的 channel buffer，recvx 指向最早被读取的数据，sendx 指向再次写入时插入的位置。



#### nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？&&&

当channel为nil时对channel的读写操作都会发生永久性的阻塞。若channel关闭则再次发送数据或者再次关闭channel都会发生panic。若channel没有关闭，分有缓冲和没缓冲的channel，没缓存的channel单独收发数据都会发生阻塞。有缓冲的在缓冲区没满时是没什么问题的。

#### 向 channel 发送数据和从 channel 读数据的流程是什么样的？&&&

#### Go 的 chan 底层数据结构和主要使用场景&&&

channel 的数据结构包含 qccount 当前队列中剩余元素个数，dataqsiz 环形队列长度，即可以存放的元素个数，buf 环形队列指针，elemsize 每个元素的大小，closed 标识关闭状态，elemtype 元素类型，sendx 队列下表，指示元素写入时存放到队列中的位置，recv 队列下表，指示元素从队列的该位置读出。recvq 等待读消息的 goroutine 队列，sendq 等待写消息的 goroutine 队列，lock 互斥锁，chan 不允许并发读写。

**无缓冲和有缓冲区别：** 管道没有缓冲区，从管道读数据会阻塞，直到有协程向管道中写入数据。同样，向管道写入数据也会阻塞，直到有协程从管道读取数据。管道有缓冲区但缓冲区没有数据，从管道读取数据也会阻塞，直到协程写入数据，如果管道满了，写数据也会阻塞，直到协程从缓冲区读取数据。

**channel 的一些特点** 1）、读写值 nil 管道会永久阻塞 2）、关闭的管道读数据仍然可以读数据 3）、往关闭的管道写数据会 panic 4）、关闭为 nil 的管道 panic 5）、关闭已经关闭的管道 panic

**向 channel 写数据的流程：** 如果等待接收队列 recvq 不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从 recvq 取出 G,并把数据写入，最后把该 G 唤醒，结束发送过程； 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； 如果缓冲区中没有空余位置，将待发送数据写入 G，将当前 G 加入 sendq，进入睡眠，等待被读 goroutine 唤醒；

**向 channel 读数据的流程：** 如果等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G，把 G 中数据读出，最后把 G 唤醒，结束读取过程； 如果等待发送队列 sendq 不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程； 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；将当前 goroutine 加入 recvq，进入睡眠，等待被写 goroutine 唤醒；

**使用场景：** 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步

#### 无缓冲channel的发送和接受是否同步

无缓冲的channel由于没有缓冲发送和接受需要同步，无缓冲是发送阻塞知道数据被接收，接收堵塞知道读到数据

#### channel注意事项

channel可以声明为只读或者只写，默认是读写都可用。

使用channel完成后记得注意关闭，不关闭阻塞会导致deadlock。

当需要不断从channel读取数据时，最好使用for-range读取channel，这样既安全又便利，当channel关闭时，for循环会自动退出，无需主动监测channel是否关闭，可以防止读取已经关闭的channel，造成读到数据为通道所存储的数据类型的零值。


### epoll


### CSP



## 杂问题

### 大文件排序


### 基本排序，那些是稳定的

保证排序的前两个相等的数其在序列的前后位置顺序和排序后他们两个的前后位置顺序相同的排序叫稳定排序

快速排序、希尔排序、堆排序、直接选择排序不是稳定的排序算法。

基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。

### go中var和make和new 的区别

变量初始化有两步，声明变量和内存分配，var关键字是声明变量，make和new函数是分配内存的

使用var初始化有两种情况：
1. 值类型：var声明值变量的同时会分配内存，然后赋予该类型零值

```go
package main
 
import "fmt"
 
func main() {
	var i int
	fmt.Println(i)
}
 
// 输出
0
```

2. 引用类型或指针类型：var只声明变量不分配内存，默认为nil。此时如果直接使用会报错。

make和new：

共同点：给变量分配内存,在分配内存

不同点：
1. 作用变量类型不同，new给string，int，和数组分配内存，make给切片，map，channel分配内存
2. 返回类型不同，new返回指向变量的指针，make返回变量本身
3. new分配的空间被清零，make分配空间后，会进行初始化
4. 分配的位置不同 自动内存逃逸？？


### 数组和切片的区别

相同点：
1. 只能存储一组相同类型的数据结构
2. 都是通过下标访问，并且有容量长度，长度通过len获取，容量通过cap获取

不同点：
1. 数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容
2. 数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变

所以是定义方式不一样，初始化方式不一样，在函数传递中，数组切片都是值传递

### for range 的时候它的地址会发生什么变化么

在 for a,b := range c 遍历中，a和b在内存中只会存在一份，即之后每次循环是遍历到的数据都是以值覆盖的方式赋给a和b，a和b的内存地址始终不变。由于有这个特性，for循环里面如果开协程，不要直接把a或者b的地址传给协程。解决办法，每次循环是，创建一个临时变量。

### uint 类型

![[Pasted image 20230302195516.png]]

小心类型溢出

### rune类型

相当int32，go的字符串底层通过byte数组实现的，go默认utf-8编码，中文占三个字节
byte等同于int8，常用来处理ascii字符
rune等同于int32 常用来处理unicode或utf-8字符

### go中解析tag是怎么实现的？反射原理是什么？

Go 中解析的 tag 是通过反射实现的，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力或动态知道给定数据对象的类型和结构，并有机会修改它。反射将接口变量转换成反射对象 Type 和 Value；反射可以通过反射对象 Value 还原成原先的接口变量；反射可以用来修改一个变量的值，前提是这个值可以被修改；tag是啥:结构体支持标记，name string `json:name-field` 就是 `json:name-field` 这部分

### 调用函数传入结构体时，是传值还是指针（go都是传值）

go中的函数参数传递都是值传递。
	函数的参数传递本质上都是值的拷贝，不同的是，值类型拷贝的是值，引用类型拷贝的是地址。
	
值传递：只在调用函数是将实际参数复制一个传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。
引用传递：调用函数式将实际参数的地址传递到函数中，那么函数汇总对参数所进行的修改，将影响到实际参数

go中map，slice，channel都是引用类型。遍历分值类型和引用类型，值类型的变量和变量的值存在同一内存位置，引用类型变量和变量的值是不同的位置，变量的值存储的是对值的引用。但并不是map、slice、channel的所有的变量在函数都能被修改，不同的数据类型底层存储结构和实现可能不太一样，情况也就不一样

（关于刚才问的 slice 为什么传到函数内可能被修改，如果 slice 在函数内没有出现扩容，函数外和函数内 slice 变量指向是同一个数组，则函数内复制的 slice 变量值出现更改，函数外这个 slice 变量值也会被修改。如果 slice 在函数内出现扩容，则函数内变量的值会新生成一个数组（也就是新的 slice，而函数外的 slice 指向的还是原来的 slice，则函数内的修改不会影响函数外的 slice。）

### 单引号双引号和反引号

单引号，表示byte或者rune类型，对应uint8和uint32，默认是rune类型，byte用来强调数据是raw data，而不是数字，而rune用来表示unicode的code point

双引号，是字符串，实际上是字符数组，可以用索引号访问某字节，也可以用len（）函数来获取字符串所占的字节长度

反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。

### go多返回值是怎么实现的&&&

Go 传参和返回值是通过 FP+offset 实现，并且存储在调用函数的栈帧中。FP 栈底寄存器，指向一个函数栈的顶部;PC 程序计数器，指向下一条执行指令;SB 指向静态数据的基指针，全局符号;SP 栈顶寄存器。

### 讲讲 Go 中主协程如何等待其余协程退出?

Go 的 sync.WaitGroup 是等待一组协程结束，sync.WaitGroup 只有 3 个方法，Add()是添加计数，Done()减去一个计数，Wait()阻塞直到所有的任务完成。Go 里面还能通过有缓冲的 channel 实现其阻塞等待一组协程结束，这个不能保证一组 goroutine 按照顺序执行，可以并发执行协程。Go 里面能通过无缓冲的 channel 实现其阻塞等待一组协程结束，这个能保证一组 goroutine 按照顺序执行，但是不能并发执行。

### Go 语言中不同的类型如何比较是否相等？

像 string，int，float interface 等可以通过 reflect.DeepEqual 和等于号进行比较，像 slice，struct，map 则一般使用 reflect.DeepEqual 来检测是否相等。

#### go中init函数的特征&&&

一个包下可以有多个init函数，每个文件也可以有多个init函数。多个init按照文件名顺序逐个初始化。应用初始化时初始化工作顺序是：从被导入的最深层包开始进行初始化，层层递出最后到main包。不管包被导入多少次，包内的init函数只会执行一次。但包级别变量的初始化先于包内 init 函数的执行。

### Go 中 uintptr 和 unsafe.Pointer 的区别？&&&

unsafe.Pointer 是通用指针类型，它不能参与计算，任何类型的指针都可以转化成 unsafe.Pointer，unsafe.Pointer 可以转化成任何类型的指针，uintptr 可以转换为 unsafe.Pointer，unsafe.Pointer 可以转换为 uintptr。uintptr 是指针运算的工具，但是它不能持有指针对象（意思就是它跟指针对象不能互相转换），unsafe.Pointer 是指针对象进行运算（也就是 uintptr）的桥梁。

### Golang程序中的包是什么？

包的本质是创建不同的文件夹，来存放程序文件。

### Printf()，Sprintf()，FprintF()都是格式化输出，有什么不同？

-   Printf格式化的字符串并输出到标准输出，一般为屏幕。
-   Sprintf格式化的字符串并返回给变量。
-   Fprintf格式化字符串并输出到文件中。

### Golang中返回局部变量的指针是否安全？

一般来说，局部变量是分配在栈上，在函数返回后会自动销毁。

在Golang中，编译器会对每个局部变量做逃逸分析，如果变量的作用域超过了该函数，那么编译器会将该局部变量分配到堆上，所以即使函数释放，该局部变量也不会受到影响。

### go拼接字符串有几种方式

1. 用“+”拼接

   最常用的方法就是，使用"+"将两个字符串进行连接，与[Python类](https://so.csdn.net/so/search?q=Python%E7%B1%BB&spm=1001.2101.3001.7020)似，不过Go语言中的字符串是不可变的类型，因此用"+"进行连接会产生一个新的字符串，这样对效率会有所影响。


```go
a := "字符串"
b := "拼接"
c := a+b
fmt.Print(c) //c = "打印字符串"
```

2. 使用sprintf函数
 第二种方法，就是使用sprintf函数，虽然不会像直接使用+那样产生临时的字符串，但效率也不高。
```go
a := "字符串"
b := "拼接"
c := fmt.Sprintf("%s%s", a, b) //c = "打印字符串"
```


3. 使用Join函数

 第三种方法就是，使用Join函数，这里需要先引入strings包才能调用Join函数，此函数会先根据字符串数组的内容，计算出一个拼接之后的长度，然后申请对应大小的内存，一个一个字符串填入，在已有一个数组的情况下，这种效率会很高，如果没有的话效率也不高。

```go
//需要先导入strings包
a := "字符串"
b := "拼接"
//定义一个字符串数组包含上述的字符串
var str []string = []string{a, b}
//调用Join函数
c := strings.Join(str, "")
fmt.Print(c)
```


4. 调用buffer.WriteString函数

第四种方法就是，调用buffer.WriteString函数，此方法的性能要远远大于上面的方法。

```go
//需要先导入bytes包
a := "字符串"
b := "拼接"
//定义Buffer类型
var bt bytes.Buffer
向bt中写入字符串
bt.WriteString(a)
bt.WriteString(b)
//获得拼接后的字符串
c := bt.String()
```

5. 用buffer.Builder

第五种方法是用buffer.Builder，此方法和上面的差不多，不过官方建议使用这个，且使用方法和上面基本一样。

```go
//需要先导入Strings包
a := "字符串"
b := "拼接"
var build strings.Builder
build.WriteString(a)
build.WriteString(b)
c := build.String()
```


### 面向对象


### interface原理

### sync.map

###  限流算法有哪些？go包自带的是基于啥？滑动窗口和一般的限流有什么区别？


### 你刚刚说到使用了Gin框架，说一下它为什么那么快

### Goroutine你怎么理解

### Goroutine为什么占用那么小内存

###  如何实现线程安全的map？使用互斥锁和Sync.Map，为什么那么快？

### 遇到过内存泄漏吗？举例说一下？说了goroutine泄漏和channel泄漏


### Go反射有了解过吗？说说原理和作用？

### go的内存管理