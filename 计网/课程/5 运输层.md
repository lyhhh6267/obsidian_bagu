# 一、运输层协议概述


## 1.1 进程之间的通信

从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，**它属于面向通信部分的最高层，同时也是用户功能中的最低层。**

当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，**只有位于网络边缘部分的主机的协议栈才有运输层**，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。

![[Pasted image 20221127013417.png]]

![[Pasted image 20221127013430.png]]

### 1.1.1 端系统之间通信的含义

“主机A和主机B进行通信”实际上是指：“运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信”。端到端的通信是进程之间的通信。

即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。
简称为“计算机之间通信”。

![[Pasted image 20221127013513.png]]

![[Pasted image 20221127013532.png]]

#### 给予端口的复用和分用功能

![[Pasted image 20221127013602.png]]

#### 屏蔽作用

运输层向高层用户屏蔽了下面网络核心的细节，它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。

![[Pasted image 20221127013632.png]]

### 1.1.2 两种不同的运输协议

但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。

当运输层采用**面向连接的 TCP 协议**时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条**可靠信道**。

当运输层采用**无连接的 UDP 协议**时，这种逻辑通信信道是一条**不可靠信道**。

![[Pasted image 20221127013959.png]]

## 1.2 运输层的两个主要协议

TCP/IP 的运输层有两个主要协议：
	1. 用户数据报协议 UDP (User Datagram Protocol)
	2. 传输控制协议 TCP (Transmission Control Protocol)

![[Pasted image 20221127014032.png]]

#### TCP与UDP

两个对等运输实体在通信时传送的数据单位叫作**运输协议数据单元** TPDU (Transport Protocol Data Unit)。

TCP 传送的数据单位协议是**TCP报文段**(segment)。
	1. 面向连接的协议，提供面向连接服务；
	2. 其传送的运输协议数据单元TPDU是 TCP 报文段；
	3. 支持点对点单播，不支持多播、广播；
	4. 提供可靠服务；
	5. 复杂。用于大多数应用，如：万维网、电子邮件、文件传送等。

UDP 传送的数据单位协议是**UDP报文**或**用户数据报**。
	1. 无连接的协议，提供无连接服务；
	2. 其传送的运输协议数据单元TPDU是 UDP 报文或用户数据报；
	3. 支持单播、多播、广播；
	4. 不提供可靠交付；
	5. 简单。适用于很多应用，如：直播应用等。


| UDP      | TCP |
| ----------- | ----------- |
| 无连接的协议，提供无连接服务；      | 面向连接的协议，提供面向连接服务；       |
| 其传送的运输协议数据单元TPDU是 UDP 报文或用户数据报；   | 其传送的运输协议数据单元TPDU是 TCP 报文段；        |
| 支持单播、多播、广播；      | 支持点对点单播，不支持多播、广播；       |
| 不提供可靠交付；   | 提供可靠服务；        |
| 简单。适用于很多应用，如：直播应用等。      | 复杂。用于大多数应用，如：万维网、电子邮件、文件传送等。       |

![[Pasted image 20221127014415.png]]

## 1.3 运输层的端口

- 运行在计算机中的进程是用进程标识符来标志的。
- 但在互联网上使用的计算机的操作系统种类很多，而**不同的操作系统又使用不同格式的进程标识符**。此外，每次软件运行的**进程标识符是可能会发生变化的**。
- 为了使运行不同操作系统的，且动态变化的计算机应用进程能够互相通信，就**必须用统一的方法**对 TCP/IP 体系的应用进程进行标志。

解决这个问题的方法就是在运输层使用协议端口号 (protocol port number)，或通常简称为**端口** (port)。

![[Pasted image 20221127014723.png]]

#### 软件端口与硬件端口

两个不同的概念。

- 在协议栈层间的抽象的协议端口是软件端口。
- 路由器或交换机上的端口是硬件端口。
- 硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。

#### TCP/IP 运输层端口

端口用一个 16 位端口号进行标志，允许有65,535个不同的端口号。

端口号只具有**本地意义**，即端口号只是为了标志**本计算机应用层中的各进程**。在互联网中，不同计算机的相同端口号是没有联系的。

![[Pasted image 20221127014900.png]]

#### 两大类端口

服务器端使用的端口号
	1. 熟知端口，数值一般为 0 ~ 1023。
	2. 登记端口号，数值为 1024 ~ 49151，没有熟知端口号的应用程序使用的。使用该范围的端口号必须在互联网数字分配机构（The Internet Assigned Numbers Authority） 登记，以防止重复。

客户端使用的端口号
	1. 又称为短暂端口号，数值为 49152 ~ 65535，留给客户进程选择暂时使用。
	2. 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。

![[Pasted image 20221127014949.png]]

# 二、用户数据报协议UDP

## 2.1 UDP概述

UDP 只在 IP 的数据报服务之上增加了很少一点的功能：
1. 运输层协议复用和分用的功能
2. 差错检测的功能

![[Pasted image 20221127015204.png]]

### UDP的主要特点

1. **UDP 是无连接的**，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
2. **UDP 使用尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
3. **UDP 是面向报文的**。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。即应用层交给 UDP 多长的报文，UDP 就照样发送。
4. **UDP 没有拥塞控制**，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。
5. **UDP 支持一对一、一对多、多对一和多对多的交互通信。**
6. **UDP 的首部开销小**，只有 8 个字节，比 TCP 的 20 个字节的首部要短。

![[Pasted image 20221127015409.png]]

## 2.2 UDP的首部格式

![[Pasted image 20221127015423.png]]

### UDP基于端口的分用

![[Pasted image 20221127015443.png]]


# 三、传输控制协议TCP概述

## 3.1 TCP最主要的特点

- TCP 是**面向连接**的运输层协议，在无连接的、不可靠的 IP 网络服务基础之上提供**可靠交付**的服务。为此，在 IP 的数据报服务基础之上，增加了保证可靠性的一系列措施。
- TCP 是**面向连接**的运输层协议。
- 每一条 TCP 连接**只能有两个端点** (endpoint)，每一条 TCP 连接**只能是点对点**的（一对一），不能进行多播和广播（一对多）。
- TCP 提供**可靠交付**的服务（**无差错、不丢失、不重复并且按序到达**）。
- TCP 提供**全双工**通信。
- **面向字节流**
	1. TCP 中的“流”(stream) 指的是流入或流出进程的字节序列。
	2. 2.“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。

### TCP 面向字节流的概念

TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系。

但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。

![[Pasted image 20221127022554.png]]

![[Pasted image 20221127022603.png]]

## 3.2 TCP的连接

- TCP 把连接作为**最基本的抽象**。
- 每一条 TCP 连接**有两个端点**。
- TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。**TCP 连接的端点叫做套接字 (socket) 。**
- **端口号拼接到 IP 地址即构成了套接字。**

### 套接字

![[Pasted image 20221127022744.png]]

![[Pasted image 20221127022754.png]]

### TCP 连接，IP 地址，套接字的关系

TCP 连接就是由协议软件所提供的一种抽象。

TCP 连接的端点是个抽象的套接字，即（IP 地址：端口号）。

**同一个 IP 地址可以有多个不同的 TCP 连接。**

**同一个端口号也可以出现在多个不同的 TCP 连接中。**

# 四、可靠传输的工作原理

IP网络所提供的的是不可靠的传输

![[Pasted image 20221127023701.png]]

## 4.1 停止等待协议

“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。

**全双工通信的双方既是发送方也是接收方**。

为了讨论问题的方便，我们仅考虑 A 发送数据，而 B 接收数据并发送确认。因此 A 叫做**发送方**，而 B 叫做**接收方**。

### 4.1.1 无差错情况

![[Pasted image 20221127024109.png]]

### 4.1.2 出现差错 问题一

在接收方 B 会出现两种情况：
	1. **B 接收 M1 时检测出了差错**，就**丢弃** M1，其他什么也不做（不通知 A 收到有差错的分组）。
	2. **M1 在传输过程中丢失了**，这时 B 当然什么都不知道，也什么都不做。

在这两种情况下，**B 都不会发送任何信息**。

但**A都必须重发分组**，直到B正确接收为止，这样才能实现可靠通信。

问题1：A如何知道要重发分组呢？

解决方法：超时重传
	1. A 为每一个已发送的分组都设置了一个**超时计时器**。
	2. A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。
	3. 若A在超时计时器规定时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组。

![[Pasted image 20221127024424.png]]

### 4.1.3 确认丢失和确认迟到

确认丢失
	1. 若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，**或者** 是 B 发送的确认丢失了。因此 **A 在超时计时器到期后就要重传 M1**。
	2. 假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动：
		第一，**丢弃**这个重复的分组 M1，不向上层交付。
		第二，**向 A 发送确认**。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。

确认迟到
	1. 传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。
	2. A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。
	3. B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。

### 4.1.4 出现差错 问题二

问题2：若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M1 。B如何知道收到了重复的分组，需要丢弃呢？

解决方法：编号

- A为每一个发送的分组都进行编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。
- B为发送的确认也进行编号，指示该确认是对哪一个分组的确认。
- A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。

### 4.1.5 确认丢失和确认迟到

![[Pasted image 20221127025631.png]]

在发送完一个分组后，必须**暂时保留**已发送的分组的副本，以备重发。

**分组和确认分组都必须进行编号**。

超时计时器的重传时间应当比数据在分组传输的平均往返时间**更长一些，为什么？**

### 4.1.6 自动重传请求ARQ

**通常 A 最终总是可以收到对所有发出的分组的确认**。如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。

**使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。**

像上述的这种可靠传输协议常称为**自动重传请求 ARQ**  (Automatic Repeat reQuest)。意思是重传的请求是自动进行的。

### 4.1.7 停止等待协要点

- 停止等待。发送方每次只发送一个分组。在收到确认后再发送下一个分组。
- 编号。对发送的每个分组和确认都进行编号。
- 自动重传请求。发送方为每个发送的分组设置一个超时计时器。若超时计时器超时，发送方会自动重传分组。
- 简单，但信道利用率太低。

![[Pasted image 20221127030934.png]]

l可以看出，当往返时间 RTT 远大于分组发送时间 TD 时，信道的利用率就会非常低。

**若出现重传**，则对传送有用的数据信息来说，**信道的利用率就还要降低**。

![[Pasted image 20221127031003.png]]

### 4.1.8 流水线传输

为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。

**流水线传输**就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。

由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。

![[Pasted image 20221127031039.png]]

## 4.2 连续ARQ协议

滑动窗口协议比较复杂，是 TCP 协议的精髓所在。

发送方维持的**发送窗口**，它的意义是：**位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认**。这样，信道利用率就提高了。

连续 ARQ 协议规定，**发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。**

![[Pasted image 20221127031606.png]]

### 4.2.1 TCP可靠传输的具体实现

- TCP 连接的每一端都必须设有两个窗口——一个**发送窗口**和一个**接收窗口**。
- TCP 的可靠传输机制用**字节的序号**进行控制。TCP 所有的确认都是基于序号而不是基于报文段。
- TCP 两端的四个窗口经常处于**动态变化**之中。
- TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算**较为合理的重传时间**。

![[Pasted image 20221127031746.png]]

![[Pasted image 20221127031756.png]]

### 4.2.2 累积确认

接收方一般采用**累积确认**的方式。即不必对收到的分组逐个发送确认，而是**对按序到达的最后一个分组发送确认**，这样就表示：**到这个分组为止的所有分组都已正确收到了。**

优点：容易实现，即使确认丢失也不必重传。
缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。

![[Pasted image 20221127032419.png]]

### 4.2.3 Go-back-N（回退 N）

如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好**把后面的三个分组都再重传一次。**

这就叫做 Go-back-N（回退 N），**表示需要再退回来重传已发送过的 N 个分组。**

![[Pasted image 20221127032744.png]]

### 4.2.4 连续 ARQ 协议与停止等待协议

|       | 连续ARQ协议 |停止等待协议 |
| ----------- | ----------- |----------- |
| 发送的分组数量      | 一次发送多个分组       |一次发送一个分组      |
| 传输控制   | 滑动窗口协议        |停止-等待       |
| 确认      | 单独确认+累积确认       |单独确认       |
| 超时定时器   | 每个发送的分组        |每个发送的分组       |
| 编号      | 每个发送的分组       |每个发送的分组       |
| 重传  | 回退N，多个分组|一个分组       |

# 五、 TCP报文段的首部格式

TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。

一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。

TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。**因此 TCP 首部的最小长度是 20 字节**。

![[Pasted image 20221127033640.png]]

- 源端口和目的端口字段——各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。
- 序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。
- 确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。说明这之前的都发了。
- 数据偏移（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。
- 保留字段——占 6 位，保留为今后使用，但目前应置为 0。
- 紧急 URG —— 当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。
- 确认 ACK —— 只有当 ACK =1 时确认号字段才有效。当 ACK =0 时，确认号无效。
- 推送 PSH (PuSH) —— 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。
- 复位 RST (ReSeT) —— 当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
- 同步 SYN —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文。
- 终止 FIN (FINish) —— 用来释放一个连接。FIN=1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。
- 窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。
- 检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。
- 紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（URG=1，紧急数据放在本报文段数据的最前面）。
- 选项字段 —— 长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”
- 填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。


# 六、TCP可靠传输的实现

## 6.1 以字节为单位的滑动窗口

- TCP 使用流水线传输和滑动窗口协议实现高效、可靠的传输。
- TCP 的滑动窗口是以字节为单位的。
- 发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。
- 发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。
- 接收窗口表示：只允许接收落入窗口内的数据。

![[Pasted image 20221127054344.png]]

![[Pasted image 20221127054355.png]]

![[Pasted image 20221127054405.png]]

![[Pasted image 20221127054414.png]]

### 6.1.1 缓存

#### 发送缓存

![[Pasted image 20221127054440.png]]

#### 接收缓存

![[Pasted image 20221127054513.png]]

#### 发送缓存与接收缓存的作用

发送缓存用来暂时存放：
	1. 发送应用程序传送给发送方 TCP 准备发送的数据；
	2.TCP 已发送出但尚未收到确认的数据。

接收缓存用来暂时存放：
	1.按序到达的、但尚未被接收应用程序读取的数据；
	2.不按序到达的数据。

### 6.1.2 强调三点

第一，A 的发送窗口并不总是和 B 的接收窗口一样大。

第二，TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。

第三，TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。

### 6.1.3 接收方发送确认

接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。

但请注意两点：
1. 第一，接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。。
2. 第二，捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据。

## 6.2 超时重传时间的选择

重传机制是 TCP 中最重要和最复杂的问题之一。
TCP 每发送一个报文段，就对这个报文段设置一次计时器。
只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。
**重传时间的选择是 TCP 最复杂的问题之一。**

### 6.2.1 TCP 超时重传时间设置

- 如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。
- 但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。
- TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。

### 6.2.2 加权平均往返时间

TCP保留了RTT的一个加权平均往返时间RTTS（这又称为平滑的往返时间）。

第一次测量到 RTT 样本时，RTTS 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTTS：


新的RTTS  =  (1 - a) ´ (旧的RTTS)  + a ´ (新的RTT样本)              (5-4)


式中，0 £ a < 1。若 a 很接近于零，表示 RTT 值更新较慢。若选择 a 接近于 1，则表示 RTT 值更新较快。

RFC 6298 推荐的 a 值为 1/8，即 0.125。

![[Pasted image 20221127055512.png]]

### 6.2.3 超时重传时间 RTO

![[Pasted image 20221127055457.png]]

## 6.3 选择确认SACK

问题：若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？

答案是可以的。选择确认 SACK  (Selective ACK) 就是一种可行的处理方法。

![[Pasted image 20221127055539.png]]

### 6.3.1 RFC2018 的规定

如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。

如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。

# 七、TCP的流量控制

## 7.1 利用滑动窗口实现流量控制

一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。

**流量控制** (flow control) 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。

利用**滑动窗口**机制可以很方便地在 TCP 连接上实现流量控制。

![[Pasted image 20221127034438.png]]

### 7.1.1 可能发送死锁

- 为了解决这个问题， TCP 为每一个连接设有一个持续计时器  (persistence timer) 。
- 只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。
- 若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。
- 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。
- 若窗口不是零，则死锁的僵局就可以打破了。

## 7.2 TCP的传输效率

### 7.2.1 糊涂窗口综合症

糊涂窗口综合症：每次仅发送一个字节或很少几个字节的数据时，有效数据传输效率变得很低的现象。

![[Pasted image 20221127034630.png]]

### 7.2.2 发送方糊涂窗口综合症

发送方 TCP **每次接收到一字节**的数据后就发送。

这样，发送一个字节需要形成 41 字节长的 IP 数据报。效率很低。

解决方法：使用 Nagle 算法。

可以用不同的机制来控制 TCP 报文段的发送时机:
	1.第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。
	2.第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push) 操作。
	3.第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。

如何控制 TCP 发送报文段的时机仍然是一个较为复杂的问题。

### 7.2.3 Nagle算法原理

![[Pasted image 20221127034747.png]]

### 7.2.4 接收方糊涂窗口综合症

当接收方的 TCP 缓冲区已满，接收方会向发送方发送窗口大小为 0 的报文。

若此时接收方的应用进程以交互方式每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。

![[Pasted image 20221127035112.png]]

解决方法：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。**只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。**

# 八、TCP的拥塞控制

## 8.1 拥塞控制的一般原理

在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞 (congestion)。

最坏结果：系统崩溃。

![[Pasted image 20221127035506.png]]

### 8.1.1 拥塞产生的原因

网络拥塞往往是由许多因素引起的。例如：
1. 点缓存的容量太小；
2. 链路的容量不足；
3. 处理机处理的速率太慢；
4. 拥塞本身会进一步加剧拥塞；
出现拥塞的原因：
 ∑ 对资源需求  > 可用资源                    (5-7)

### 8.1.2拥塞控制与流量控制的区别

| 拥塞控制 | 流量控制 |
| --- | ----------- |
| 防止过多的数据注入到网络中，使网络中的路由器或链路不致过载； | 抑制发送端发送数据的速率，以使接收端来得及接收； |
| 是一个全局性的过程，涉及到与降低网络传输性能有关的所有因素。 | 是点对点通信量的控制，是端到端的问题； |

### 8.1.3 一味地增加资源能解决拥塞吗？

不能。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。

网络拥塞往往是由许多因素引起的。例如：
1. 增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞；
2. 提高处理机处理的速率会将瓶颈转移到其他地方；

![[Pasted image 20221127035946.png]]

### 8.1.4 开环控制与闭环控制

| 开环控制 | 闭环控制 |
| --- | ----------- |
| 在设计网络时，事先考虑周全，力求工作时不发生拥塞； | 基于反馈环路的概念； |
| 思路：力争避免发生拥塞。 | 根据网络当前的运行状态采取相应控制措施； |
|  | 思路：在发生拥塞后，采取措施进行控制，消除拥塞。 |

#### 闭环控制

属于闭环控制的有以下几种措施：
1. 监测网络系统，以便检测到拥塞在何时、何处发生。
2. 将拥塞发生的信息传送到可采取行动的地方。
3. 调整网络系统的运行以解决出现的问题。

#### 监测网络的拥塞

主要指标有：
1. 由于缺少缓存空间而被丢弃的分组的百分数；
2. 平均队列长度；
3. 超时重传的分组数；
4. 平均分组时延；
5. 分组时延的标准差，等等。

上述这些指标的上升都标志着拥塞的增长。

## 8.2 TCP的拥塞控制方法

- TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。
- TCP发送方维持一个拥塞窗口 cwnd (Congestion Window)
- 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。
- 发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：
		真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)

### 8.2.1 控制拥塞窗口的原则

只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。

但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。

#### 拥塞的判断

重传定时器超时：网络可能已经发生了拥塞。
（如果不是网络质量问题）

收到三个重复的 ACK：预示网络可能会出现拥塞。
（实际可能还未发生拥塞）

### 8.2.2 TCP拥塞控制算法

四种拥塞控制算法（RFC 5681） ：
	慢开始 (slow-start)
	拥塞避免 (congestion avoidance)
	快重传 (fast retransmit)
	快恢复 (fast recovery)

#### 慢开始

目的：用来确定网络的负载能力或拥塞程度。

算法的思路：由小到大逐渐增大拥塞窗口数值。

两个变量：
	拥塞窗口：
		初始拥塞窗口值：2 种设置方法。
			1 至 2 个最大报文段 （旧标准）
			2 至 4 个最大报文段 （RFC 5681）
		窗口值逐渐增大。
	慢开始门限：
		防止拥塞窗口增长过大引起网络拥塞。

![[Pasted image 20221127041901.png]]

![[Pasted image 20221127041931.png]]

#### 传输轮次

- 使用慢开始算法后，每经过一个传输轮次 (transmission round)，拥塞窗口 cwnd 就加倍。
- 一个传输轮次所经历的时间其实就是往返时间 RTT。
- “传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。
- 例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。

#### 拥塞避免算法

- **思路**：让拥塞窗口 cwnd **缓慢地增大**，避免出现拥塞。
- 每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。
- 使拥塞窗口 cwnd **按线性规律缓慢增长**。
- 在拥塞避免阶段，具有 “**加法增大**” (Additive Increase) 的特点。

![[Pasted image 20221127044624.png]]

#### 当网络出现拥塞时

无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（**重传定时器超时**）：
1. ssthresh = max (cwnd/2，2)
2. cwnd = 1
3. 执行慢开始算法

目的：迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

![[Pasted image 20221127045131.png]]

#### 快重传算法

发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”）。
使用快重传可以使整个网络的吞吐量提高约20%。

不难看出，快重传并非取消重传计时器，而是在某些情况下可以更早地（更快地）重传丢失的报文段。

![[Pasted image 20221127045545.png]]

#### 快回复算法

当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法 FR (Fast Recovery) 算法：
1. 慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；
2. 新拥塞窗口 cwnd = 慢开始门限 ssthresh ；
3. 开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。

![[Pasted image 20221127045628.png]]

#### 发送窗口的上限值

发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：

发送窗口的上限值 = Min [rwnd, cwnd]                (5-9)

当 rwnd < cwnd 时，是接收方的接收能力限制发送窗口的最大值。
当 cwnd < rwnd 时，则是网络的拥塞限制发送窗口的最大值。

## 8.3 主动队列管理AQM

# 九、TCP的运输连接管理

TCP 是面向连接的协议。

TCP 连接有三个阶段：
1. 连接建立
2. 数据传送
3. 连接释放

TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行。

TCP 连接的建立采用**客户服务器方式**。

主动发起连接建立的应用进程叫做**客户** (client)。

被动等待连接建立的应用进程叫做**服务器** (server)。

## 9.1 TCP的连接建立

TCP 建立连接的过程叫做握手。

握手需要在客户和服务器之间交换三个 TCP 报文段。称之为**三报文握手**。

![[Pasted image 20221127050619.png]]

1. B的 TCP 服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。
2. A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。
3. B 的 TCP 收到连接请求报文段后，如同意，则发回确认。
4. B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号 ack = x + 1，自己选择的序号 seq = y。
5. A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1。
    A 的 TCP 通知上层应用进程，连接已经建立。
6. B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。

## 9.2 TCP的连接释放

TCP 连接释放过程比较复杂。

数据传输结束后，通信的双方都可释放连接。

TCP 连接释放过程是**四报文握手**。

![[Pasted image 20221127051804.png]]

1. 数据传输结束后，通信的双方都可释放连接。
现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。
A 把连接释放报文段首部的FIN = 1，其序号seq = u，等待 B 的确认。

2. B 发出确认，确认号 ack = u+1，而这个报文段自己的序号 seq = v。
TCP 服务器进程通知高层应用进程。
从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。

3. 若 B 已经没有要向 A 发送的数据，
其应用进程就通知 TCP 释放连接。

4. A 收到连接释放报文段后，必须发出确认。

5.  在确认报文段中ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。

### 报货计时器

用来防止在TCP连接出现长时期的空闲。

保活计时器 通常设置为2小时 。若服务器过了2小时还没有收到客户的信息，它就发送探测报文段（心跳）。若发送了10个探测报文段（每一个相隔75秒）还没有响应，就假定客户出了故障，因而就终止该连接。








